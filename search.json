[{"title":"数据库系统概论一（绪论)","url":"/2023/07/10/Day1/","content":"数据库系统概论一（绪论)\n一、数据库系统概述（一）数据库的4个基本概念1、数据：数据是数据库中存储的基本对象\n2、数据库：顾名思义，是存放数据的仓库\n3、数据库管理系统：是位于用户与操作系统之间的一层数据管理软件\n主要功能包括以下几个方面：\n（1）数据定义功能,DDL\n（2）数据组织、存储和管理\n（3）数据操纵功能\n（4）数据库的事务管理和运行管理\n（5）数据库的建立和维护功能\n（6）其他功能\n4、数据库系统：由数据库、数据库管理系统、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统\n（二）数据管理的三个阶段1、人工管理阶段：无共享、冗余度极大\n2、文件系统阶段：共享性差、冗余度大\n3、数据库系统阶段：共享性高、冗余度小\n（三）数据库系统的特点1、数据结构化：数据库系统实现整体数据的结构化，这是主要特征之一，也是数据库系统和文件系统的本质区别\n2、数据的共享性高、冗余度低且易扩充：数据共享可以大大减少数据冗余，节约存储空间。数据共享还能够避免数据之间的不相容性与不一致性\n3、数据独立性高：数据独立性高包括物理独立性和逻辑独立性\n4、数据由数据库管理系统统一管理和控制：数据库管理系统必须提供以下几方面的数据控制功能：（1）数据的安全性保护（2）数据的完整性检查（3）并发控制（4）数据库恢复\n二、数据模型数据模型也是一种模型，它是对现实世界数据特征的抽象\n（一）两类数据模型第一类是概念模型，第二类是逻辑模型和物理模型。\n概念模型：信息模型，主要用于数据库设计\n逻辑模型：主要包括层次模型、网状模型、关系模型、面向对象模型和对象关系数据模型、半结构化数据模型。主要用于数据库管理系统的实现\n物理模型：是对数据最底层的抽象。\n（二）概念模型1、信息世界中的基本概念\n（1）实体：客观存在并相互可区别的实物称为实体\n（2）属性：实体所具有的某一特性称为属性\n（3）码：唯一标识实体的属性集称为码\n（4）实体型：用实体名和属性名来抽象刻画共同类实体\n（5）实体集：同一类型实体的集合，例如全体学生就是一个实体集\n（6）联系：在现实世界中，事物内部以及事物之间是有联系的\n2、实体-联系方法\nE-R图，来描述现实世界的概念模型，E-R方法也称为E-R模型。\n（三）数据模型的组成要素数据模型通常由数据结构、数据操作和数据完整性约束条件三部分组成。\n1、数据结构\n数据结构描述数据库的组成对象以及对象之间的联系\n2、数据操作\n数据操作是指对数据库中各种对象的实例允许执行的操作的集合，包括操作以及有关的操作规则\n3、数据完整性\n数据的完整性约束条件是一组完整性规则\n4、常用的数据模型：\n\n层次模型\n网状模型\n关系模型\n面向对象数据模型\n对象关系数据模型\n半结构化数据模型\n\n（四）层次模型最早用到的数据模型。\n层次模型用树形结构来表示各种实体以及实体间的联系。\n1、层次模型的数据结构：\n在数据库中定义满足下面两个条件的基本层次联系的集合为层次模型\n（1）有且只有一个结点没有双亲结点，这个结点称为根结点\n（2）根意外的其他结点有且只有一个双亲结点\n2、层次模型的优缺点\n优点：（1）层次模型的数据结构比较简单清晰\n（2）层次数据库的查询效率高\n（3）层次数据模型提供了良好的完整性支持\n缺点：（1）现实世界中很多联系是非层次的\n（2）如果一个结点具有多个双亲结点，用层次模型这类联系就很笨拙\n（3）查询子女结点必须通过双亲结点\n（4）由于结构严密，层次命令趋于程序化\n（五）网状模型网状数据模型的典型代表是DBTG系统\n1、网状模型的数据结构\n在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型：\n（1）允许一个以上的结点无双亲\n（2）一个结点可以有多于一个的双亲\n层次模型中子女结点与双亲结点的联系是唯一的，而在网状模型中这种联系可以不唯一。\n2、网状模型的优缺点\n优点：（1）能够更为直接的描述现实世界，如一个结点可以有多个双亲，结点之间可以有多种联系。\n（2）具有良好的性能，存取效率较高\n缺点：（1）结构比较复杂，随着应用环境扩大，数据库的结构就变得越来越复杂\n（2）网状模型的DDL、DML复杂\n（六）关系模型关系模型是最重要的一种数据模型。关系数据库系统采用关系模型作为数据的组织方式。\n1、关系模型的数据结构\n关系模型要求关系必须是规范化的，关系的每一个分量必须是一个不可分的数据项。\n2、关系模型的数据操纵和完整性约束\n关系的完整性约束条件三大类：实体完整性、参照完整性和用户定义完整性。\n关系模型中的数据操作是集合操作，操作对象和操作结果都是关系，关系模型把存取路径向用户隐蔽起来，用户只要指出“干什么”或“找什么”，不必详细说明“怎么干”或“怎么找”，大大提高数据的独立性，提高了用户的生产率\n3、关系模型的优缺点\n优点：（1）关系模型与格式化模型不同，它是建立在严格的数学概念的基础上的。\n（2）关系模型的概念单一。简单易用\n（3）存取路径对用户透明，从而具有更高的数据独立性。\n缺点：查询效率不够高\n三、数据库系统的结构（一）数据库系统模式的概念在数据模型中有“型”和“值”的概念\n模式是数据库中全体数据的逻辑结构和特征的描述。\n模式是相对稳定的，而实例是相对变动的。\n数据库在体系结构上通常都具有相同的特征，即三级模式结构并提供两级映像功能。\n（二）数据库系统的三级模式结构1、模式：模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图\n2、外模式：外模式也称为子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示\n3、内模式：内模式也称为存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。\n（三）数据库的二级映像功能与数据独立性1、外模式：当模式改变时，由数据库管理员对各个外模式的映像做出相应改变，可以使外模式不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简述数据的逻辑独立性。\n2、内模式映像：当数据存储结构改变时，由数据库管理员对内模式映像做出相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性，简称数据的物理独立性。\n数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，减少了应用程序的维护和修改。\n四、数据库系统的组成1、硬件平台以及数据库‘\n2、软件\n3、人员\n（1）数据库管理员：\n①决定数据库中的信息内容和结构\n②决定数据库的存储结构和完整性约束条件\n③定义数据的安全性要求和完整性约束条件\n④监控数据库的使用和运行\n⑤数据库的改进和重组、重构\n（2）系统分析员和数据库设计人员\n（3）应用程序员\n（4）用户\n习题：1、试述数据、数据库、数据库管理系统、数据库系统的概念\n2、使用数据库系统有什么好处？\n3、试述文件系统与数据库系统的区别和联系。\n4．举出适合用文件系统而不是数据库系统的应用例子，以及适合用数据库系统的应用例子。\n5、试述数据库系统的特点。\n6、数据库管理系统的主要功能有哪些？\n7、什么是概念模型？试达概念模型的作用。\n8、定义并解释概念模型中以下术语：实体，实体型，实体集，实体之间的联系\n9、試述数据模型的概念、数据模型的作用和数堀模型的三个要素。\n10、试述层次模型的概念，举出三个层次模型的实例。\n11、试述网状模型的概念，举出三个网状模型的实例。\n12、试述网状、层次数据库的优缺点。\n13、试述关系模型的概念，定义并解释以下木语：关系，属性，域，元组，码，分量，关系模式\n14、试达关系数据库的特点。\n15、试述数据库系统的三级模式结构，并说明这种结构的优点是什么。\n16、定义并解释以下术语：模式，外模式，内模式，数据定义语言，数据揳纵语言\n17．什么叫数据与程序的物理独立性？什么叫数据与程序的逻辑独立性？为什么数据库系统具有数据与程序的独立性？\n18、试述数据库系统的组成。\n19、试述数据库管理员、系统分析员、数据库设计人员、应用程序员的指责。\n20、OLTP和OLAP的区别\n","categories":["DataBase"],"tags":["DataBase"]},{"title":"数据库系统概论二（关系型数据库)","url":"/2023/07/11/Day2/","content":"数据库系统概述二（关系型数据库）\n一、关系数据结构及形式化定义（一）关系关系模型的数据结构非常简单，只包含单一的数据结构——关系。这里从集合论角度给出关系结构数据的形式化定义。\n1、域\n域是一组具有相同数据类型的值的集合。\n2、笛卡尔积\n给定一组域，允许其中某些域是相同的，D1,D2,……,Dn的笛卡尔积为\n{D1*D2………..D3}&#x3D;{(d1,d2,…,dn)|di ∈ Di , i &#x3D; 1 , 2 , 3 , …….. , n}\n其中(d1,d2,…,dn)叫做一个n元组，或简称元组，元素中每一个di叫做一个分量。\n一个域中允许的不同取值个数称为这个域的基数。\n3、关系\n若关系中的某一个属性组能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。若一个关系有多个候选码，则选定其中一个为主码。\n候选码的诸属性为主属性。\n关系可以有三种类型：基本关系、查询表和视图表。\n基本关具有以下六个性质：\n（1）列是同质的，每一个列中的分量都来自同一类型数据，来自同一个域。\n（2）不同的列可出自同一个域，称其中的每一列位一个属性。\n（3）列的顺序无所谓。\n（4）任意两个元组的候选码不能取相同的值。\n（5）行的顺序无所谓。\n（6）分量必须取原子值。\n这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项。\n规范化的关系简称为范式。\n（二）关系模式关系的描述称为关系模式，它可以形式化表示R(U,D,DOM,F)\nR为关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。\n关系模式可以简记为R(U)或R(A1,A2,…,An)\n（三）关系数据库在关系模型中，实体及实体间的联系都是用关系来表示的。在一个给定的应用领域中，所有关系的集合构成一个关系数据库。\n关系数据库的型称为关系数据库模式，是对关系数据库的描述。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库\n（四）关系模型的存储结构二、关系操作（一）基本的关系操作关系模型中常用的关系操作包括查询和插入、删除、修改操作两大部分。\n关系的查询表达能力很强，是关系操作中最主要的部分，其中选择、投影、并、差、笛卡尔积是5种基本操作，其他操作可以用基本操作来定义和导出。\n关系操作的特点是集合操作方式，即操作的对象和结果都是集合。\n（二）关系数据语言的分类早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数和关系演算。另外还有一种介于关系代数和关系演算之间的结构化语言——SQL。SQL不仅具有丰富的查询功能，而且具有数据定义和数据控制功能，是集查询、数据定义语言、数据操纵语言和数据控制语言于一体的关系数据语言。\n三、关系的完整性（一）实体完整性关系数据库中的每个元组应该是可区分的，是唯一的。\n规则1、实体完整性\n例如学生（学号，姓名，性别，专业号，年龄）关系中学号为主码，则学号不能为空\n（二）参照完整性例如：学生（学号，姓名，性别，专业号，年龄）\n专业（专业号，专业名）\n这两个关系之间存在着属性的引用，即学生关系引用了专业关系的主码“专业号”。\n规则2、参照完整性规则\n（三）用户定义的完整性任何关系数据库系统都应该支持实体完整性和参照完整性。\n四、关系代数关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。\n关系代数的运算按运算符的不同可分为传统的集合运算和专门的关系运算两类。\n（一）传统的集合运算传统的集合运算是二目运算，包括并，差，交，笛卡尔积四种运算。\n\n\n（二）专门的关系运算专门的关系运算包括选择、投影、连接、除运算等。\n1、选择\n选择又称为限制。\n\n\n\n\n选择查询\n2、投影\n关系R上的投影是从R中选择出若干属性列组成新的关系。\n\n3、连接\n连接也称为θ连接。\nθ为“&#x3D;”的连接运算称为等值连接。自然连接是一种特殊的等值连接。\n\n\n\n\n4、除运算\n设关系R除以关系S的结果为关系T，则T包含所有在R但不在S中的属性及其值，且T的元组与S的元组的所有组合都在R中。\n\n\n五、关系演算（一）元组关系演算语言ALPHAALPHA语言主要有GET、PUT、HOLD、UPDATE、DELETE、DROP六条语句。语句的基本格式为\n操作语句 工作空间名（表达式）：操作条件\n1、检索操作\n用GET语句实现\n（1）简单检索（不带条件）\n例：\nGET W(SC.Cno)\nW为工作空间名。这里条件为空\n查询所有学生的数据\nGET W(Student)\n（2）限定检索\n查询所有小于20岁的学生的学号和年龄\nGET W(Student.Sno,Student.Sage): Student.Sdept &#x3D; “IS”^Student.Sage&lt;20\n（3）带排序的检索\n降序\nGET W(Student.Sno,Student,Sage): Student.Sdept &#x3D; “CS” DOWN Student.Sage\n（5）用元组变量的检索\n例：\n查询信息系学生的名字\nRANGE Student X\nGET W(X.Sname) : X.Sdept&#x3D;’IS’\nALHPA语言用RANGE来说明元组变量。本例中X是关系Student上的元组变量，用途是简化关系名，即用X代表Student\n（6）用存在量词的检索\n查询选修2号课程的学生的名字\nRANGE SC X\nGET W(Student.Sname) : 彐X(X.Sno&#x3D;Student^X.Cno&#x3D;’2’)\n2、更新操作\n（1）修改操作\n修改操作用UPDATE语句实现。\n①首先用 HOLD语句将要修改的元组从数据库中读到工作空间中；\n②然后用宿主语言修改工作空间中元组的属性值：\n③最后用 UPDATE 语句将修改后的元组送回数据库中。需要注意的是，单纯检素数据使用 GET 语句即可，但为修改数据而读元组时必须使用HOLD 语句，HOLD语句是带上并发控制的 GET 语句。\n例：\n把201215127 学生从计算机科学系转到信息系。HOLD W (Student.Sno, Student Sdept): Student.Sno&#x3D;201215127（从 Student 关系中读出 201215127 学生的数据)MOVE ‘IS’ TO W.Sdept(用宿主语言进行修改）UPDATE W(把修改后的元组送回 Student 关系）\n（2）插入操作\n插入操作用PUT语句实现\n①首先用宿主语言在工作空间中建立新元组；②然后用 RUT 语句把该元组存入指定的关系中。例：学校新开设了一门2 学分的课程“计算机组织与结构”，其课程号为 8，直接先行课为 6 号课程。插入该课程元组。MOVE ‘8’ TO W.CnoMOVE 计算机组织与结构’TO W.CnameMOVE ‘6’ TO W.CpnoMOVE ‘2’ TO W.CcreditPUT W (Course)（3）删除刪除操作用 DELETE 语句实现。其步骤为：①用HOLD 语句把要删除的元组从数据库中读到工作空间中：②用 DELETE 语句删除 该元组。例： 201215230 学生因故退学，删除该学生元组。HOLD W (Student): Student.Sno ‘201215230DELETE W\n（二）元组关系演算在元组关系演算系统中，称{t|φ(t)}为元组演算表达式。t为元组变量，φ(t)为元组关系演算公式。\n（三）域关系演算语言QBE域关系演算以元组变量的分量（即域变量）作为谓词变元的基本对象。\nQBE是Query By Example（即通过例子进行查询）的简称。\n习题：1、试述关系模型的三个组成部分。\n2、简述关系数据语言的特点和分类。\n3、定义并理解下列术语，说明它们之间的联系与区别：（1）域，笛卡儿积，关系，元组，属性：（2） 主码，候选码，外码：（3）关系模式，关系，关系数据库。\n4、举例说明关系模式和关系的区别。\n5、试述关系模型的完整性规则。在参照完整性中，什么情况下外码属性的值可以为空值？\n6、试述等值连接与自然连接的区别和联系。\n7、关系代数的基本运算有哪些？如何用这此基本运算来表示其他运算？\n","categories":["DataBase"],"tags":["DataBase"]},{"title":"数据库系统概论三（关系型数据库标准语言SQL)","url":"/2023/07/13/Day3/","content":"数据库系统概述三（关系型数据库标准语言SQL）\n一、SQL概述（一）SQL发展目前，没有一个数据库系统能够支持SQL标准的所有概念和特性\n（二）SQL的特点1、综合统一\n2、高度非过程化\n只要提出“做什么”，而无需指明“怎么做”，因此无需了解存取路径。存取路径的选择以及SQL的操作过程由系统自动完成。\n3、面向集合的操作方式\n4、以同一种语法结构提供多种使用方式\n5、语言简洁，易学易用\n（三）SQL的基本概念支持SQL的关系数据库管理系统同样支持关系数据库三级模式结构。\n二、学生-课程数据库以学生-课程数据库为例讲解SQL的数据定义等语句\n\n学生表：Student(Sno,Sname,Ssex,Sage,Sdept)\n\n课程表：Course(Cno,Cname,Cpno,Ccredit)\n\n学生选课表：SC(Sno,Cno,Grade)\n\n\n\n\n一个关系数据库管理系统的实例可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。\n三、数据定义（一）模式的定义与删除1、定义模式\nCREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;\n\n例：为用户WANG定义一个学生-课程模式S-T\nCREATE SCHEMA&quot;S-T&quot; AUTHORIZATION WANG;\n\n例：\nCREATE SCHEMA AUTHORIZATION WANG;\n\n该语句没有指定&lt;模式名&gt;，所以&lt;模式名&gt;隐含为用户名WANG\n例：为用户ZHANG创建一个模式TEST，并且在其中定义一个表TAB1\nCREATE SCHEMA TEST AUTHORIZATION ZHANGCREATE TABLE TAB1(COL1 SMALLINT,\t\t\t \t  COL2 INT,\t\t\t\t  COL3 CHAR(20),\t\t\t\t  COL4 NUMERIC(10,3),\t\t\t\t  COL5 DECIMAL(5,2));\n\n2、删除模式\n在SQL中，删除模式语句如下：\nDROP SCHEMA&lt;模式名&gt;&lt;CASCADE|RESTRICT&gt;\n\n例3.4：\nDROP SCHEMA ZHANG CASCADE\n\n这句话删除模式ZHANG，同时，该模式中定义的表TAB1也被删除了\n（二）基本表的定义、删除与修改1、定义基本表\nSQL使用CREATE TABLE语句来定义基本表，其基本格式如下：\nCREATE TABLE&lt;表名&gt;(&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]\t\t\t\t,&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]\t\t\t\t...\t\t\t\t[,&lt;表级完整性约束条件&gt;]\t\t\t\t)\n\n例：建立一个“学生”表Student\nCREATE TABLE Student(Sno CHAR(9) PRIMARY KEY,Sname CHAR(20) UNIQUE,Ssex CHAR(2),Sage SMALLINT,Sdept CHAR(20));\n\n例：建立一个“课程”表Course\nCREATE TABLE Course(Cno CHAR(4) PRIMARY KEY,Cname CHAR(40) NOT NULL,Cpno CHAR(4),Ccredit SMALLINT,FOREIGN KEY (Cpno) REFERENCES Course(Cno))\n\n例：建立学生选课表SC\nCREATE TABLE SC(Sno CHAR(9),Cno CHAR(4),Grade SMALLINT,PRIMARY KEY(Sno,Cno),FOREIGN KEY(Sno) REFERENCES Student(Sno),FOREIGN KEY(Cno) REFERENCES Cource(Cno))\n\n2、数据类型\n\n\n\n\n3、修改基本表\nALTER TABLE&lt;表名&gt;[ADD [COLUMN] &lt;新列名&gt;&lt;数据类型&gt;[完整性约束]][ADD&lt;表级完整性约束&gt;][DROP [COLUMN] &lt;列名&gt;[CASCADE|RESTRICT]][DROP CONSTRAINT&lt;完整性约束名&gt; [RESTRICT|CASCADE]][ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt;]\n\n(三)索引的建立与删除数据库索引有多种类型，常见的有顺序文件上的索引、B+树索引、hash索引、位图索引等。\n顺序文件上的索引：按定属性值升序或降序存储\nB+树索引：将索引属性组织成B+树形式，B+树的叶结点为属性值和相应的元组指针，B+树索引具有动态平衡优点。\nhash索引：建立若干个桶，将索引属性按照其hash函数映射到相应桶中，桶中存放索引属性值和相应的元组指针。hash索引具有查找速度快的特点。\n位图索引：用位向量记录索引属性中可能出现的值，每个位向量对应一个可能值。\n1、建立索引\n使用CREATE INDEX语句，一般格式为\nCREATE [UNIQUE][CLUSTER] INDEX&lt;索引名&gt;ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]...)\n\n例：为学生-可成数据库中的Student、Course和SC三个表建立唯一索引。其中Student是按照升序建立唯一索引，Course表按课程号升序建立唯一索引，SC表按照学号升序和课程表降序建立唯一索引\nCREATE UNIQUE INDEX Stusno ON Student(Sno);CREATE UNIQUE INDEX Coucno On Course(Cno);CREATE UNIQUE INDEX SCno ON SC(Sno ASC,Cno DESC);\n\n2、修改索引\n例：将SC表中的SCno索引名改为SCSno\nALTER INDEX SCno RENAME TO SCSno;\n\n3、删除索引\n例：删除Student表的Stusname索引\nDROP INDEX Stusname;\n\n四、数据的增删改查具体可以看以下博客：\nSQL的增删改查\n五、视图视图时从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍放在原来的基本表中。\n视图一经定义，就可以跟基本表一样被查询、被删除。也可以在一个视图之上再定义新的视图，但是对新视图的（增、删、改）操作有一定的限制。\n定义视图1、建立视图\nSQL语言用 create view 命令建立视图，其一般格式为：\ncreate view &lt;视图名&gt; [ ( &lt;列名&gt; [ ，&lt;列名&gt; ]... ) ]as &lt;子查询&gt;                                                            [ with check option ]                                          \n\n其中子查询可以是任意的select子句，是视图数据的来源。\nwith check option 表示对视图进行 update、insert、delete 操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询语句中的条件表达式）\n组成视图的属性列名或者全部省略或者全部指定，没有第三章并选择。如果省略了视图个各个属性列名，则隐含该视图由子查询中select子句目标列中的诸字段组成。但是在下列三种情况下必须明确的指定组成视图的所有列名：\n（1）某个目标列不是单纯的属性名，而是聚集函数或表达式式\n（2）多表连接时选出了几个同名列作为视图的字段\n（3）需要在视图中为某个列启用新的更合适的名字\n例：建立软件工程专业学生的视图\ncreate view SG_Studentasselect Sno,Sname,Sagefrom Studentwhere Sdept=&#x27;软件工程&#x27;;\n\n关系数据库管理系统执行create view语句的结果只是把视图的定义存入数据字典，并不执行其中的select 语句。只是在对视图查询时，才按照视图的定义从基本表中将视图查出。\n例：建立软件工程专业学生的视图，并要求进行修改和插入操作时仍需要保证该视图只有软件工程专业的学生。\ncreate view SG_Studentasselect Sno,Sname,Sagefrom Studentwhere Sdept=&#x27;软件工程&#x27;with check option;\n\n由于在定义SG_Student 视图时加上了with check option 子句，以后对该视图进行插入、修改和删除操作时，关系数据库管理系统会自动加上 Sdept&#x3D;’软件工程’ 的条件。\n例：定义一个反应学生出生年份的视图\ncreate view BT_S （Sno,Sname,Sbirth）asselect Sno,Sname,2021-Sagefrom Student;\n\n视图中的出生年份时通过计算得到的。\n2、删除视图\n该语句格式为： drop view &lt;视图名&gt; [ cascade ] ；\n视图删除后视图的定义将从数据字典中删除。如果视图还导出了其他视图，则使用cascade级联删除语句把该视图和由它导出的视图一起删除。\n查询视图视图定义后，用户就可以向&#x3D;像对基本表一样对视图进行查询了。\n关系数据库管理系统执行对视图的查询时，首先进行有效性检查，检查查询中涉及的表、视图是否存在。如果存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。这一转换过程称为视图消解 。\n视图的作用1、视图能够简化用户的操作\n2、视图使用户能以多种角度看待同一数据\n3、视图对重构数据库提供了一定程度上的逻辑独立性\n4、视图能够对机密数据提供安全保护\n5、适当利用视图可以更清晰的表达\n习题：SQL语句习题大全\n","categories":["DataBase"],"tags":["DataBase"]},{"title":"SUNDB安装部署","url":"/2023/07/11/SUNDB%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%9F%B9%E8%AE%AD/","content":"SUNDB安装部署\n一、安装前环境验证和配置（一）服务器资源确认1、CPU（lscpu）\nArchitecture（CPU架构）：x86_64\nCPU（s）：2\n型号：AMD Ryzen 7 6800H with Radeon Graphics\nNUMA节点0 CPU：0,1\n2、内存（free -h）\nMem对应的行是内存查询的信息，total表示内存总量，free表示剩余内存。\n3、硬盘（fdisk -l）\n命令：df -h\n下面命令是查看当前文件系统挂载的分区的使用情况\n命令：smartctl –scan\n下面命令是查看当前系统各个硬盘的接口类型\n4、网卡（ifconfig）\n下载网络包：yum -y install net-tools\nethtool：Port后面是网口类型，FIBRE代表光口，Speed后面是网口的传输速度\n（二）软件环境确认1、内核版本（uname -a）：\n2、操作系统版本（cat &#x2F;etc&#x2F;os-release）\n3、JAVA版本（java -version）\njava安装：https://blog.csdn.net/A_yonga/article/details/125526307?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168903943016800213014388%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168903943016800213014388&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-125526307-null-null.142^v88^insert_down1,239^v2^insert_chatgpt&amp;utm_term=linux%E5%AE%89%E8%A3%85java%E7%8E%AF%E5%A2%83&amp;spm=1018.2226.3001.4187\n解压指令以及创建新文件夹\nmkdir /usr/local/java/tar -zxvf jdk-8u371-linux-x64.tar.gz -C /usr/local/java/vi /etc/profileexport JAVA_HOME=/usr/local/java/jdk1.8.0_371export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATHln -s /usr/local/java/jdk1.8.0_371/bin/java /usr/bin/javaln -s /usr/local/java/jdk1.8.0_371/bin/java /usr/bin/java\n\n（三）性能校准数据1、硬盘读写I&#x2F;O\n使用dd命令可以测试硬盘读写I&#x2F;O\n2、网络带宽、延迟\n使用qperf或iperf来测试网络带宽和网络延迟。以qperf为例，假设要在A和B两台服务器之间测试其网络带宽和网络延迟。\n（四）安全限制配置1、查看防火墙状态\n命令：systemctl status firewalld\n关闭防火墙服务，针对当前系统正在运行的防火墙服务。\n命令：systemctl stop firewalld\n关闭后重新查询\n命令：systemctl status firewalld\n禁用防火墙服务，针对可能重启系统的情况，防止重启后自动运行防火墙。\n命令：systemctl disable firewalld\n2、SELINUX\n一般没有特殊设置时，selinux是运行状态，可以使用命令临时关闭。\n命令：setenforce 0\n要想永久关闭selinux，还需要编辑配置文件：&#x2F;etc&#x2F;selinux&#x2F;config，将其中的配置项：SELINUX&#x3D;enforcing替换为SELINUX&#x3D;disabled。\n3、主机名\n查询主机名命令：hostname\n修改主机名为gs08：hostnamectl set-hostname gs08\n临时生效修改主机名：hostname gs08\n（五）时间设置新部署的环境，应尽量保证时间统一以避免因时间差异引发的系统问题。尤其是在分布式集群环境中，各节点的时间应保持统一。通常的做法是部署本地的NTP服务，所有内网的服务器都从本地NTP服务端同步时间。\n1、NTP软件安装\n安装NTP服务所需软件：\nyum  -y  install  ntpyum  -y  install  ntpdate\n\n尝试启动并查看NTP服务：\nsystemctl status ntpd.servicesystemctl start ntpd.servicesystemctl stop ntpd.service\n\n2、NTP服务端配置\n选择192.168.123.11作为本地NTP服务端，因此在该服务器上按照本小节的描述进行服务端配置。\nNTP的配置文件是&#x2F;etc&#x2F;ntp.conf，编辑该文件，修改或添加下面内容：\nserver 127.127.1.0fudge 127.127.1.0 stratum 1restrict -4 default kod notrap nomodify nopeer noquery limitedrestrict -6 default kod notrap nomodify nopeer noquery limitedrestrict 192.168.123.0 mask 255.255.0.0 nomodifyrestrict 127.0.0.1restrict ::1\n\n 3、NTP客户端配置\n在除服务端以外的其他内网服务器上，修改NTP配置文件&#x2F;etc&#x2F;ntp.conf。将其中默认的server配置注释掉，加入下面一行：\nserver  192.168.123.11\n\n4、时间同步验证\n可以使用ntpstat命令查看同步状态。一般服务启动后需要5-10分钟后才能成功连接和同步。\n（六）用户准备1、 创建安装用户\n创建名为sundb的操作系统用户：\nuseradd sundb\n\n修改用户密码：\npasswd sundb\n\n2、配置环境变量\n切换到sundb用户：\nsu - sundb\n\n配置sundb用户的环境变量，通常是修改家目录下的.bash_profile隐藏文件：\nexport SUNDB_HOME=$&#123;HOME&#125;/product/sundb_homeexport SUNDB_DATA=$&#123;HOME&#125;/product/sundb_dataexport PATH=.:$SUNDB_HOME/bin:$&#123;HOME&#125;/bin:$PATHexport CLASSPATH=$SUNDB_HOME/lib/sundb8.jar:$SUNDB_HOME/sample:$&#123;CLASSPATH&#125; export LD_LIBRARY_PATH=$&#123;SUNDB_HOME&#125;/lib:$&#123;LD_LIBRARY_PATH&#125;\\#一些命令的别名，安装好sundb后会用到alias gs=&#x27;gsql sys gliese --as sysdba --prompt=gSQL&#x27;alias gst=&#x27;gsqlnet test test&#x27;alias gtrc=&#x27;tail -100f $SUNDB_DATA/trc/system.trc&#x27;\n\n编辑环境变量并保存后记得执行source  ~&#x2F;.bash_profile，使之生效。\n（七）用户资源限制和系统内核参数设置1、编辑配置文件&#x2F;etc&#x2F;security&#x2F;limits.conf\n增大打开文件的最大数量和进程最大数目的限制，如下配置并保存：\nsundb  hard   nofile 65535sundb  soft   nofile 65535sundb  hard   nproc  65535sundb  soft   nproc  65535\n\n\n\n2、&#x2F;etc&#x2F;systemd&#x2F;logind.conf\n修改配置之前首先备份一下：\ncp -i /etc/systemd/logind.conf /etc/systemd/logind.conf_prev\n\n编辑&#x2F;etc&#x2F;systemd&#x2F;logind.conf配置文件，将RemoveIPC的设置改为no:\n[Login]RemoveIPC=no\n\n修改后执行下面命令生效：\nsystemctl restart systemd-logind\n\n\n\n3、&#x2F;etc&#x2F;sysctl.conf\n由于SUNDB数据库使用到共享内存和信号量，为防止因为系统默认共享内存和信号量的配额导致资源不足，在部署前需要调大系统内核参数中跟共享内存和信号量相关的参数。\n另外当使用Client-Server方式连接数据库并且吞吐量较大时，为了减少网络瓶颈，需要将监听队列大小设置和相应的内核参数调大。\n二、安装部署（一）单机安装部署w 准备安装包\n安装部署过程要在事先准备好的sundb用户下进行，因此首先登录或切换到sundb用户：\n[root@gs08]# su - sundb \t[sundb@gs08]$ pwd/home/sundb\n\n将安装包上传到该目录下并通过md5校验安装包是否完整\n[sundb@gs08 ~]$ md5sum sundb-server-5.0.22.1.0-linux-x86_64.tar.gz\n\n9bf0eb1228d6facf3ef8327f31691696  sundb-server-5.0.22.1.0-linux-x86_64.tar.gz\n解压安装包并将其重命名为product，使用product没有别的特殊原因，仅仅因为名称短，方便且习惯。也可以使用原目录名称或改为其他名称，只是需要注意在1.7.2配置环境变量中将环境变量的路径与之对应即可。\n[sundb@gs08]$ tar -zxvf sundb-server-5.0.22.1.0-linux-x86_64.tar.gz[sundb@gs08]$ mv sundb-server-5.0.22.1.0-linux-x86_64 product\n\n登记许可信息\n将1.5 license申请阶段申请到的license信息存放到$SUNDB_HOME&#x2F;license&#x2F;license文件中。\n创建数据库\n使用gcreatedb命令创建数据库，下面是一个使用示例。\ngcreatedb --db_name=&quot;sundb&quot; --db_comment=&quot;sundb database&quot; --timezone=&quot;+08:00&quot; --character_set=&quot;UTF8&quot; --char_length_units=&quot;OCTETS&quot; --silent\n\n想要了解更多gcreatedb命令相关的参数，可以使用gcreatedb –help查看帮助信息。\n启动数据库实例\n可以通过数据库命令行交互工具gsql来启动数据库并执行各种sql语句和数据库管理命令。更多关于gsql工具的资料请自行查阅官方手册。\n[sundb@gs08 ~]$ gsql sys gliese --as sysdba Copyright © 1999 CSII Inc. All rights reserved. Release 5.0 22.1.0 revision(28cd72e)Connected to an idle instance. gSQL&gt; startup\n\nStartup success\n\n创建数据字典\n为了能够查询系统及相关对象的信息，需要生成如下schema：\nDICTIONARY_SCHEMA: 由DBA*,ALL,USER_等查询对象信息的视图和表组成。\nINFORMATION_SCHEMA:由包含在SQL标准的INFORMATION_SCHEMA中的视图和表组成。\nPERFORMANCE_VIEW_SCHEMA:通过组合固定表的信息来查询系统信息的视图组成。\n操作方法如下：\ngsql sys gliese --as sysdba --import $SUNDB_HOME/admin/standalone/DictionarySchema.sqlgsql sys gliese --as sysdba --import $SUNDB_HOME/admin/standalone/InformationSchema.sqlgsql sys gliese --as sysdba --import $SUNDB_HOME/admin/standalone/PerformanceViewSchema.sqlgsql sys gliese --as sysdba --import $SUNDB_HOME/script/tech_tablespace_standalone.sql\n\n启动监听\n想要应用能通过网络连接访问数据库，则需要开启数据库监听。开启监听命令及输出如下：\n[sundb@gs08 ~]$ glsnr --start\n\n Copyright © 1999 CSII Inc. All rights reserved.\n Release 5.0 22.1.0 revision(28cd72e)\nListener is started successfully.\n查看监听状态、端口等命令和输出如下：\n[sundb@gs08 ~]$ glsnr --status\n\n Copyright © 1999 CSII Inc. All rights reserved.\n Release 5.0 22.1.0 revision(28cd72e)\nListener process ID : 218928\nListener configuration file : &#x2F;home&#x2F;sundb&#x2F;product&#x2F;sundb_data&#x2F;conf&#x2F;sundb.listener.conf\nUnix Domain Path : &#x2F;tmp&#x2F;unix-glsnr.22881.0\nTCP Listen Host : 0.0.0.0, Port : 22881\ndefault C&#x2F;S mode : Dedicated\nConnection Timeout(second) : 100\nListener is running.\n关闭监听命令及输出如下：\n[sundb@gs08 ~]$ glsnr --stop\n\n Copyright © 1999 CSII Inc. All rights reserved.\n Release 5.0 22.1.0 revision(28cd72e)\nListener is stopped.\n测试网络连接\n启动监听后可以使用gsqlnet工具测试网络连接是否可用。因为gsqlnet使用ODBC接口，因此需要首先配置ODBC数据源。\n在操作系统用户sundb家目录下创建.odbc.ini隐藏文件：\ntouch .odbc.ini\n\n编辑.odbc.ini文件将，将下面内容写入该文件：\n[SUNDB]PROTOCAL=TCPHOST=192.168.123.15PORT=22881CS_MODE=DEDICATEDUID=testPWD=test\n\n通常这样配置就可以找到ODBC数据源了，但有时可能会出现找不到数据源的情况，如果检查确认.odbc.ini配置没有错误，则可以在操作系统用户sundb的环境变量中增加一项：\nexport ODBCINI=$&#123;HOME&#125;/.odbc.ini\n\n使用gsqlnet测试通过C&#x2F;S方式连接数据库：\n[sundb@gs08 ~]$ gsqlnet sys gliese --as sysdba\n\n Copyright © 1999 CSII Inc. All rights reserved.\n Release 5.0 22.1.0 revision(28cd72e)\nConnected to SUNDB Database.\ngSQL&gt;\n不指定数据源时默认会寻找名称为SUNDB的数据源配置，如果.odbc.ini中配置的数据源名称不是使用SUNDB，则需要使用–dsn选项指定数据源：\ngsqlnet sys gliese --as sysdba --dsn SUNDB\n\n\n\n（二）分布式数据库集群安装部署三、卸载（一）单机卸载关闭监听：\nglsnr --stop\n\n关闭数据库实例：\nshutdown normal\n\n或\nshutdown immediate\n或\nshutdown abort\n删除数据文件，如果没有修改过参数配置文件，那么默认情况下数据库文件在$SUNDB_HOME&#x2F;db&#x2F;路径下，删除该目录下的数据文件：\nrm -rf $SUNDB_DATA/db/*.dbf\n\n如果设置了别的数据文件存储路径，则在相应的路径下删除数据文件即可。\n删除控制文件和日志文件，如果没有修改过参数配置文件，那么默认情况下控制文件和redo日志文件在$SUNDB_HOME&#x2F;wal&#x2F;路径下，删除该目录下的*.ctl后缀和*.log后缀的文件：\nrm -rf $SUNDB_DATA/wal/*.ctlrm -rf $SUNDB_DATA/wal/*.log\n\n如果设置了非默认的路径，则在相应路径下删除相关文件即可。\n删除归档文件，如果没有修改过参数配置文件，那么默认情况下归档文件在$SUNDB_HOME&#x2F;archive_log&#x2F;路径下，删除该目录下的*.log后缀的文件：\nrm -rf $SUNDB_DATA/archive_log/*.log\n\n如果为归档文件存储设置了别的路径，则在相应路径下删除归档文件即可。\n查看有无残留共享内存、信号量、队列：\nipcs\n如果有，则需要清理：\nipcs -m | grep $LOGNAME | awk &#x27;&#123;print &quot;ipcrm -m &quot; $2&#125;&#x27; | sh -vipcs -s | grep $LOGNAME | awk &#x27;&#123;print &quot;ipcrm -s &quot; $2&#125;&#x27; | sh -vipcs -q | grep $LOGNAME | awk &#x27;&#123;print &quot;ipcrm -q &quot; $2&#125;&#x27; | sh -v\n\n最后，如果是永久卸载，清理安装目录、还原环境变量配置，即将环境变量中添加的配置删掉：\nrm -rf $SUNDB_HOMErm -rf $SUNDB_DATA\n\n如果是删库后还可能重建库，则无需清理安装目录和环境变量配置。\n（二）分布式数据库集群卸载四、重装（一）单机重装单机的重装基本上就是卸载+重新建库。\n（二）分布式集群重装五、强杀主进程SUNDB的进程有：\ngmaster：主进程，负责数据库性能及监控、数据刷盘、日志刷盘、归档、资源回收、集群恢复、故障转移等。\ngserver：服务进程，负责处理用户发送的请求。\nglsnr：监听进程，负责监听连接请求。\ngbalancer：负载均衡进程，针对cs-shared模式。\ngdispatcher：调度进程，针对cs-shared模式。\ncdispatcher：集群调度进程，负责集群间通信的调度。\ncserver：集群服务进程，负责处理集群间请求的进程。\n（一）断应用杀会话集群环境杀应用会话可以使用下面的命令：\nselect &#x27;alter system DISCONNECT session &#x27;||id||&#x27;,&#x27;||serial||&#x27; at &#x27;||cluster_member_name ||&#x27; ; &#x27; from  x$session  t1 where  dbc_type &lt;&gt;&#x27;UNKNOWN&#x27;  and not exists (select 1 from  (select cluster_member_name ,session_id() id ,session_serial() serial from dual) t2 where  t1.cluster_member_name=t2.cluster_member_name and  t1.id=t2.id and t1.serial=t2.serial); \n\n单机环境杀应用会话可以使用下面的命令：\nselect &#x27;alter system DISCONNECT session &#x27;||id||&#x27;,&#x27;||serial||&#x27; ; &#x27; from  x$session  t1 where  dbc_type &lt;&gt;&#x27;UNKNOWN&#x27;\n\n\n\n（二）清理进程为了防止有残留的进程，杀进程时最好把所有数据库的进程都杀一遍：\nps -ef | grep &quot;gmon&quot; | grep $LOGNAME | kill -9 `awk &#x27;&#123;print $2&#125;&#x27;`ps -ef | grep &quot;gmaster&quot; | grep $LOGNAME | kill -9 `awk &#x27;&#123;print $2&#125;&#x27;`ps -ef | grep &quot;gserver&quot; | grep $LOGNAME | kill -9 `awk &#x27;&#123;print $2&#125;&#x27;`ps -ef | grep &quot;gdispatcher&quot; | grep $LOGNAME | kill -9 `awk &#x27;&#123;print $2&#125;&#x27;`ps -ef | grep &quot;gbalancer&quot; | grep $LOGNAME | kill -9 `awk &#x27;&#123;print $2&#125;&#x27;`ps -ef | grep &quot;cdispatcher&quot; | grep $LOGNAME | kill -9 `awk &#x27;&#123;print $2&#125;&#x27;`ps -ef | grep &quot;cserver&quot; | grep $LOGNAME | kill -9 `awk &#x27;&#123;print $2&#125;&#x27;`ps -ef | grep &quot;gsql&quot; | grep $LOGNAME | kill -9 `awk &#x27;&#123;print $2&#125;&#x27;`ps -ef | grep &quot;cyclone&quot; | grep $LOGNAME | kill -9 `awk &#x27;&#123;print $2&#125;&#x27;`\n\n\n\n（三）清理共享内存使用下面命令清理共享内存：\nipcs -m | grep $LOGNAME | awk &#x27;&#123;print &quot;ipcrm -m &quot; $2&#125;&#x27; | sh -v\n\n\n\n（四）清理信号量使用下面命令清理信号量：\nipcs -s | grep $LOGNAME | awk &#x27;&#123;print &quot;ipcrm -s &quot; $2&#125;&#x27; | sh -v\n\n\n\n（五）清理队列使用下面命令清理队列：\nipcs -q | grep $LOGNAME | awk &#x27;&#123;print &quot;ipcrm -q &quot; $2&#125;&#x27; | sh -v\n\n\n\n（六）重启数据库在执行完上面清理各种系统残留的步骤后，可以重新启动数据库\ngsql sys gliese --as sysdbagSQL&gt; startup\n\n\n\n（七）注意监听重启数据库后记得查看监听是否启动：\nglsnr --statusglsnr --start\n\n","categories":["SUNDB"],"tags":["SUNDB"]},{"title":"数据库系统概论四（数据库完整性)","url":"/2023/07/13/Day4/","content":"数据库系统概述四（数据库完整性）\n数据的完整性指的是数据的正确性和相容性\n一、实体完整性（一）定义实体完整性通常来说就是定义主码\n（二）实体完整性检查和违约处理1、检查主码值是否唯一，如果不唯一则拒绝插入或修改\n2、检查主码值的各个属性是否为空，只要一个为空就拒绝插入或修改\n检查记录中主码值是否唯一的一种方法是进行全表扫描，依次判断表中每一条记录的主码值与将插入记录的主码值是否相同。\n全表扫描非常耗时，为了避免这种情况，关系数据库管理系统一般都在主码上自动建立一个索引，如B+树索引，通过索引查找基本表中是否已经存在新的主码值，大大提升效率。\n二、参照完整性（一）定义参照完整性关系模型的参照完整性在CREATE TABLE中用FOREGIN KEY短语定义哪些列为外码，用REFERENCES短语指明外码参照哪些表的主码。\n例如，关系SC中的一个元组表示一个学生选修的某门课程的成绩，（Sno，Cno）是主码，Sno和Cno分别参照Student表的主码和Course表中的主码。\n例：定义SC中的参照完整性\nCREATE TABLE SC(Sno CHAR(9) NOT NULL,Cno CHAR(9) NOT NULL,Grade SMALLINT,PRIMARY KEY(Sno,Cno),FOREGIN KEY(Sno) REFERENCES Student(Sno),     /*在表级定义参照完整性*/FOREGIN KEY(Cno) REFERENCES Student(Cno)     /*在表级定义参照完整性*/);\n\n（二）参照完整性检查和违约处理\n\n三、用户定义的完整性（一）属性上的约束条件\n列值非空（NOT NULL）\n列值唯一（UNIQUE）\n检查列值是否满足一个条件表达式（CHECK）\n\n\n\n\n\n（二）元组上的约束条件\n\n四、完整性约束命名子句1、完整性约束命名子句\nCONSTRAINT&lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;\n\n包括NOT NULL,UNIQUE,PRIMARY KEY,FOREIGN KEY,CHECK短语等。\n\n\n2、修改表中的完整性限制\n可以使用ALTER TABLE语句修改表中的完整性限制\n\n\n五、断言在SQL中可以使用数据定义语言中的CREATE ASSERTION语句，通过声明性断言来指定更具有一般性的约束。\n1、创建断言的格式\nCREATE ASSERETION &lt;断言名&gt;&lt;CHECK子句&gt;\n\n例：数据库课程限制最多60名学生选修\nCREATE ASSERTION ASSE_SC_DB_NUM\tCHECK(60&gt;=(SELECT COUNT(*)\t\tFROM Course,SC\t\tWHERE SC.CNO=COURSE.CNO AND COURSE.CNAME=&#x27;数据库&#x27;;\t)\n\n2、删除断言的语句格式\nDROP ASSERTION&lt;断言名&gt;\n\n六、触发器触发器是一种特殊类型的存储过程，它不同于存储过程，主要是通过事件触发而被执行的。而存储过程则需要主动调用其名字执行\n注意\n1、在 MySQL 5 中，触发器名必须在每个表中唯一，但不是在每个数据库中唯一，即同一数据库中的两个表可能具有相同名字的触发器2、每个表的每个事件每次只允许一个触发器，因此，每个表最多支持 6 个触发器，before&#x2F;after insert、before&#x2F;after delete、before&#x2F;after update\n优缺点：\n优点：可以保证数据安全，并进行安全校验\n缺点：过分依赖触发器，影响数据库的结构，增加数据库的维护成本\n语法\ndelimiter 自定义结束符号 create trigger 触发器名字 触发时间 触发事件 on 表 for each row begin   end 自定义的结束符合 delimiter ;\n\n1、触发器时间\n当 SQL 指令发生时，会令行中数据发生变化，而每张表中对应的行有两种状态：数据操作前和操作后\n\nbefore：表中数据发生改变前的状态\nafter：表中数据发生改变后的状态\n\n2、触发事件\n触发器是针对数据发送改变才会被触发，对应的操作只有\n\nINSERT\nDELETE\nUPDATE\n\n定义触发器\nCREATE TRIGGER &lt;触发器名&gt;     ON &lt;表名&gt;FOR/AFTER/INSTEAD [DELETE,INSERT,UPDATE]AS   &lt;触发动作体&gt;GO\n\n删除触发器\nDROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;\n\n","categories":["DataBase"],"tags":["DataBase"]}]